{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "37268e6b-0102-4fd4-8d7a-0d841b8f87da",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "D:\\Anaconda\\Lib\\site-packages\\torchvision\\models\\_utils.py:208: UserWarning: The parameter 'pretrained' is deprecated since 0.13 and may be removed in the future, please use 'weights' instead.\n",
      "  warnings.warn(\n",
      "D:\\Anaconda\\Lib\\site-packages\\torchvision\\models\\_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and may be removed in the future. The current behavior is equivalent to passing `weights=ResNet18_Weights.IMAGENET1K_V1`. You can also use `weights=ResNet18_Weights.DEFAULT` to get the most up-to-date weights.\n",
      "  warnings.warn(msg)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Predictions have been saved to test_out.csv!\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import os\n",
    "from PIL import Image\n",
    "import numpy as np\n",
    "from torchvision import transforms\n",
    "import torch\n",
    "from torchvision.models import resnet18\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "import re\n",
    "\n",
    "# Load the datasets and take only the first 1000 entries\n",
    "train_df = pd.read_csv('dataset/train.csv').head(1000)\n",
    "test_df = pd.read_csv('dataset/test.csv').head(1000)\n",
    "\n",
    "# Define image transformations\n",
    "transform = transforms.Compose([\n",
    "    transforms.Resize((224, 224)),\n",
    "    transforms.ToTensor()\n",
    "])\n",
    "\n",
    "def load_images(image_folder):\n",
    "    image_files = [f for f in os.listdir(image_folder) if f.endswith('.jpg')]\n",
    "    images = []\n",
    "    skipped_files = []\n",
    "    \n",
    "    for image_file in image_files:\n",
    "        image_path = os.path.join(image_folder, image_file)\n",
    "        try:\n",
    "            image = Image.open(image_path).convert('RGB')\n",
    "            image = transform(image)\n",
    "            images.append(image)\n",
    "        except Exception as e:\n",
    "            # Log the error and skip the image\n",
    "            print(f\"Error loading {image_file}: {e}\")\n",
    "            skipped_files.append(image_file)\n",
    "    \n",
    "    return torch.stack(images), skipped_files\n",
    "\n",
    "# Load images\n",
    "train_images, skipped_train = load_images('images/train')\n",
    "test_images, skipped_test = load_images('images/test')\n",
    "\n",
    "# Load a pre-trained ResNet model\n",
    "model = resnet18(pretrained=True)\n",
    "model.eval()\n",
    "\n",
    "def extract_features(images):\n",
    "    features = []\n",
    "    with torch.no_grad():\n",
    "        for image in images:\n",
    "            feature = model(image.unsqueeze(0))\n",
    "            features.append(feature.squeeze().numpy())\n",
    "    return np.array(features)\n",
    "\n",
    "# Extract features from images\n",
    "train_features = extract_features(train_images)\n",
    "test_features = extract_features(test_images)\n",
    "\n",
    "def preprocess_entity_value(value):\n",
    "    # Use regular expression to extract numeric value\n",
    "    numeric_value = re.findall(r\"[-+]?\\d*\\.\\d+|\\d+\", value)\n",
    "    if numeric_value:\n",
    "        return float(numeric_value[0])  # Return numeric part as float\n",
    "    return None\n",
    "\n",
    "# Extract numeric values from entity_value\n",
    "y_train_numeric = train_df['entity_value'].apply(preprocess_entity_value)\n",
    "\n",
    "# Drop rows where numeric value couldn't be extracted\n",
    "valid_indices = y_train_numeric.notna()\n",
    "y_train_numeric = y_train_numeric[valid_indices]\n",
    "X_train_filtered = train_features[valid_indices]  # Assuming train_features corresponds to the rows in train_df\n",
    "\n",
    "# Define and train the model\n",
    "model = RandomForestRegressor(n_estimators=100)\n",
    "model.fit(X_train_filtered, y_train_numeric)\n",
    "\n",
    "# Make predictions\n",
    "X_test = test_features  # Ensure this is correctly defined\n",
    "predictions = model.predict(X_test)\n",
    "\n",
    "# Format predictions\n",
    "def format_prediction(pred):\n",
    "    # Formatting predictions as \"x unit\"\n",
    "    return \"{:.2f} gram\".format(pred)  # Adjust if you use different units\n",
    "\n",
    "formatted_predictions = [format_prediction(pred) for pred in predictions]\n",
    "\n",
    "# Create the output DataFrame\n",
    "output_df = pd.DataFrame({\n",
    "    'index': test_df['index'],  # Ensure 'index' is available in test_df\n",
    "    'prediction': formatted_predictions\n",
    "})\n",
    "\n",
    "# Save the DataFrame to a CSV file\n",
    "output_df.to_csv('test_out.csv', index=False)\n",
    "\n",
    "print(\"Predictions have been saved to test_out.csv!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9b361e12-41c3-488d-897f-06268114d99b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
